// Generated by purs version 0.11.5
"use strict";
var $foreign = require("./foreign");
var Control_Applicative = require("../Control.Applicative");
var Control_Bind = require("../Control.Bind");
var Control_Monad_Aff = require("../Control.Monad.Aff");
var Control_Monad_Aff_Unsafe = require("../Control.Monad.Aff.Unsafe");
var Control_Monad_Eff = require("../Control.Monad.Eff");
var Control_Monad_Eff_Class = require("../Control.Monad.Eff.Class");
var Control_Monad_Eff_Exception = require("../Control.Monad.Eff.Exception");
var Control_Semigroupoid = require("../Control.Semigroupoid");
var Data_Array = require("../Data.Array");
var Data_Foldable = require("../Data.Foldable");
var Data_Function = require("../Data.Function");
var Data_Functor = require("../Data.Functor");
var Data_List = require("../Data.List");
var Data_List_Types = require("../Data.List.Types");
var Data_Maybe = require("../Data.Maybe");
var Data_Time_Duration = require("../Data.Time.Duration");
var Data_Unit = require("../Data.Unit");
var Partial_Unsafe = require("../Partial.Unsafe");
var Signal = require("../Signal");
var Signal_Channel = require("../Signal.Channel");
var Text_Smolder_Markup = require("../Text.Smolder.Markup");
var waitState = function (until) {
    return function (app) {
        return Control_Monad_Aff.makeAff(function (error) {
            return function (success) {
                return $foreign.waitState_(until)(app)(success);
            };
        });
    };
};
var waitEvent = function (until) {
    return function (app) {
        return Control_Monad_Aff.makeAff(function (error) {
            return function (success) {
                return $foreign.waitEvent_(until)(app)(success);
            };
        });
    };
};
var onlyEffects = function (state) {
    return function (effects) {
        return {
            state: state, 
            effects: effects
        };
    };
};
var noEffects = function (state) {
    return {
        state: state, 
        effects: [  ]
    };
};
var start = function (config) {
    return function __do() {
        var v = Signal_Channel.channel(Data_List_Types.Nil.value)();
        var mapAffect = function (affect) {
            return Control_Monad_Aff.launchAff(Control_Monad_Aff_Unsafe.unsafeCoerceAff(Control_Bind.bind(Control_Monad_Aff.bindAff)(affect)(function (v1) {
                if (v1 instanceof Data_Maybe.Nothing) {
                    return Control_Applicative.pure(Control_Monad_Aff.applicativeAff)(Data_Unit.unit);
                };
                if (v1 instanceof Data_Maybe.Just) {
                    return Control_Bind.discard(Control_Bind.discardUnit)(Control_Monad_Aff.bindAff)(Control_Monad_Aff.delay(0.0))(function () {
                        return Control_Monad_Eff_Class.liftEff(Control_Monad_Aff.monadEffAff)(Signal_Channel.send(v)(Data_List.singleton(v1.value0)));
                    });
                };
                throw new Error("Failed pattern match at Pux line 64, column 9 - line 68, column 51: " + [ v1.constructor.name ]);
            })));
        };
        var foldState = function (effModel) {
            return function (ev) {
                return config.foldp(ev)(effModel.state);
            };
        };
        var foldEvents = function (evs) {
            return function (effModel) {
                return Data_Foldable.foldl(Data_List_Types.foldableList)(foldState)(noEffects(effModel.state))(evs);
            };
        };
        var evSignal = Signal_Channel.subscribe(v);
        var input = Data_Maybe.fromJust()(Signal.mergeMany(Data_Functor.functorArray)(Data_Foldable.foldableArray)(Data_Array.snoc(Data_Functor.map(Data_Functor.functorArray)(Data_Functor.map(Signal.functorSignal)(Data_List.singleton))(config.inputs))(evSignal)));
        var effModelSignal = Signal.foldp(foldEvents)(noEffects(config.initialState))(input);
        var effectsSignal = Signal.flippedMap(Signal.functorSignal)(effModelSignal)(function ($9) {
            return Data_Functor.map(Data_Functor.functorArray)(mapAffect)((function (v1) {
                return v1.effects;
            })($9));
        });
        var stateSignal = Signal["dropRepeats'"](Signal.flippedMap(Signal.functorSignal)(effModelSignal)(function (v1) {
            return v1.state;
        }));
        var htmlSignal = Signal.flippedMap(Signal.functorSignal)(stateSignal)(config.view);
        Signal.runSignal(Signal.flippedMap(Signal.functorSignal)(effectsSignal)(Data_Foldable.sequence_(Control_Monad_Eff.applicativeEff)(Data_Foldable.foldableArray)))();
        return $foreign.start_({
            markup: htmlSignal, 
            state: stateSignal, 
            events: input, 
            input: v
        });
    };
};
var mapState = function (a2b) {
    return function (effmodel) {
        return {
            state: a2b(effmodel.state), 
            effects: effmodel.effects
        };
    };
};
var mapEffects = function (a2b) {
    return function (effmodel) {
        return {
            state: effmodel.state, 
            effects: Data_Functor.map(Data_Functor.functorArray)(Data_Functor.map(Control_Monad_Aff.functorAff)(Data_Functor.map(Data_Maybe.functorMaybe)(a2b)))(effmodel.effects)
        };
    };
};
module.exports = {
    mapEffects: mapEffects, 
    mapState: mapState, 
    noEffects: noEffects, 
    onlyEffects: onlyEffects, 
    start: start, 
    waitEvent: waitEvent, 
    waitState: waitState
};
